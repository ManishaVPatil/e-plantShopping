import React, { Component } from 'react';
import { connect } from 'react-redux';
import PropTypes from 'prop-types';
import _ from 'underscore';
import valid from 'card-validator';
import ReCAPTCHA from 'react-google-recaptcha';
import FormElements from '../FormElements/FormElements';
import * as constantValues from '../../../store/constants/config';
import * as actions from '../../../store/actions/index';
import * as checkoutDetailDataUtil from '../../../utils/CheckoutDetailDataUtil/CheckoutDetailDataUtil';
import { getStateListFromCountryStateMapping, findRequestedObject } from '../../../utils/MyAccountDataUtil/MyAccountDataUtil';
import Icon from '../Icon/Icon';
import * as myAccountDataUtil from '../../../utils/MyAccountDataUtil/MyAccountDataUtil';
import FormDropDown from '../FormElements/FormDropDown';
import Tooltip from '../Tooltip/Tooltip';

class Forms extends Component {


    constructor(props) {
        super(props);
        this.state = {
            ...props.state,
            emailAlreadyExist : true
        };
        this.selectedSpanRef = React.createRef();
    }

    /*This function is used to let React know if a componentâ€™s output is not affected by the current change in state or props
    * This method is invoked before rendering when new props or state are being received 
    * Ideally setState shouldn't be executed in this lifecycle function.
    */
    shouldComponentUpdate(nextProps, nextState) {
        /* Updating the state to update the form data with the provided formDefinition on user based action.
         * We are validating the below mention condition to ensure it is executed only on particular user action */
        if (_.isBoolean(nextProps.updateFormState) && this.props.updateFormState !== nextProps.updateFormState) {
            const updatedFormDefinition = this.getValidatedFormDefinition(nextProps.formDefinition);
            const _enteredValue = !_.isEmpty(updatedFormDefinition) && !_.isObject(updatedFormDefinition) && !_.isEmpty(updatedFormDefinition.cardNumber) && _.isNumber(updatedFormDefinition.cardNumber.value) ? updatedFormDefinition.cardNumber.value : null;
            const creditCardBrandName = checkoutDetailDataUtil.getCreditCardBrandName(_enteredValue);
            /* Update the credit card CVV limit */
            if (!_.isNull(creditCardBrandName)) {
                this.updateCreditCardCVVLimit(creditCardBrandName, updatedFormDefinition, true);
            }
            /* set updated definition of form to redux */
            this.props.onInitFormDetailUpdateInStore(this.getUpdatedFormFieldValues(updatedFormDefinition), this.state.formType, false);
            /* set state to update form */
            this.setState({
                formDefinition: updatedFormDefinition
            });
        }
        const dropDownFormFieldAccess = nextProps.dropDownFormFieldAccess, prevDropDownFormFieldAccess = this.props.dropDownFormFieldAccess;
        if (!_.isEmpty(dropDownFormFieldAccess) && !_.isEmpty(dropDownFormFieldAccess.searchUserInput) && /ARROWUP|ARROWDOWN/i.test(dropDownFormFieldAccess.searchUserInput)) {
            let dataIndex = 0, dropDownFormFieldAccessElements = document.querySelectorAll(`[id^=${dropDownFormFieldAccess.elementIdentifier}ListElement]`);
            dropDownFormFieldAccessElements.forEach(elem => {
                if (_.indexOf(elem.classList, "current") >= 0) {
                    dataIndex = Number(elem.getAttribute("data-index"));
                    if (dataIndex < (dropDownFormFieldAccessElements.length - 1)) {
                        setTimeout(function () {
                            elem.classList.remove("current");
                        }, 150);
                    }
                }
            });
            if (_.isEmpty(prevDropDownFormFieldAccess) && /ARROWUP|ARROWDOWN/i.test(dropDownFormFieldAccess.searchUserInput)) {
                if (_.isElement(document.getElementById(`${dropDownFormFieldAccess.elementIdentifier}ListElement${dataIndex}`))) {
                    document.getElementById(`${dropDownFormFieldAccess.elementIdentifier}ListElement${dataIndex}`).focus();
                    setTimeout(function () {
                        document.getElementById(`${dropDownFormFieldAccess.elementIdentifier}ListElement${dataIndex}`).classList.add("current");
                    }, 100);
                }
            } else if (!_.isEmpty(prevDropDownFormFieldAccess) && /ARROWDOWN/i.test(dropDownFormFieldAccess.searchUserInput)) {
                if (_.isElement(document.getElementById(`${dropDownFormFieldAccess.elementIdentifier}ListElement${dataIndex + 1}`))) {
                    document.getElementById(`${dropDownFormFieldAccess.elementIdentifier}ListElement${dataIndex + 1}`).focus();
                    setTimeout(function () {
                        document.getElementById(`${dropDownFormFieldAccess.elementIdentifier}ListElement${dataIndex + 1}`).classList.add("current");
                    }, 100);
                }
            } else if (!_.isEmpty(prevDropDownFormFieldAccess) && /ARROWUP/i.test(dropDownFormFieldAccess.searchUserInput)) {
                if (document.getElementById(`${dropDownFormFieldAccess.elementIdentifier}ListElement${dataIndex - 1}`)) {
                    document.getElementById(`${dropDownFormFieldAccess.elementIdentifier}ListElement${dataIndex - 1}`).focus();
                    setTimeout(function () {
                        document.getElementById(`${dropDownFormFieldAccess.elementIdentifier}ListElement${dataIndex - 1}`).classList.add("current");
                    }, 100);
                }
                if (dataIndex === (dropDownFormFieldAccessElements.length - 1) && _.isElement(document.getElementById(`${dropDownFormFieldAccess.elementIdentifier}ListElement${dataIndex}`))) {
                    document.getElementById(`${dropDownFormFieldAccess.elementIdentifier}ListElement${dataIndex}`).classList.remove("current");
                }
            }
        }
        return true;
    }

    componentDidUpdate(prevProps, prevState) {
        const dropDownFormFieldData = this.props.dropDownFormFieldData, prevDropDownFormFieldData = prevProps.dropDownFormFieldData;
        if (!_.isEmpty(dropDownFormFieldData) && !_.isEmpty(dropDownFormFieldData.searchUserInput) && /^[a-zA-Z]$/.test(dropDownFormFieldData.searchUserInput)) {
            const dropDownOptions = document.getElementById(dropDownFormFieldData.elementIdentifier);
            if (!_.isNull(dropDownOptions)) {
                const dropdownOptionsList = [...dropDownOptions.querySelectorAll('.option')];
                let dropdownElement;
                let shouldScroll = false;
                for (let i = 0; i < dropdownOptionsList.length; i++) {
                    dropdownElement = dropdownOptionsList[i];
                    if (!_.isEmpty(dropdownElement.textContent) && dropdownElement.textContent[0].toUpperCase() === dropDownFormFieldData.searchUserInput) {
                        shouldScroll = true;
                        break;
                    }
                }
                if (_.isEmpty(prevDropDownFormFieldData) || (!_.isEmpty(prevDropDownFormFieldData) && prevDropDownFormFieldData.searchUserInput !== dropDownFormFieldData.searchUserInput && shouldScroll)) {
                    dropdownElement.focus();
                }
            }
        }
        if (this.state.formType=== constantValues.FORM_TYPE_REVIEW_ORDER && prevProps.isGiftMessageEnabled === false && this.props.isGiftMessageEnabled === true && document.querySelector(".gift-info-container")) {
            setTimeout(() => document.querySelector(".gift-info-container").focus(), 500);
        }
    }


    /**
     * This function is used to provide the state field definition based on the provided parameters
     * @param {STRING} {
     *      @type contains either `textbox` or `dropdown`
     *      @countryCode contains the country code for which state mapping is required
     * }
     * @returns {*|JSON}
     **/
    getNewStateFieldDefinition = (type, countryCode) => {
        if ("textbox" === type) {
            return {
                fieldFormat: 'single',
                fieldType: 'textbox',
                elementType: 'input',
                elementConfig: {
                    type: 'text',
                    id: 'customerBillingState',
                    name: 'Customer Billing State',
                    className: 'form-control',
                    autoComplete: "off",
                    'aria-describedby': 'State'
                },
                isStateField: true,
                displayValue: '',
                value: '',
                label: this.props.scriptingJson[constantValues._LBL_FORM_STATE],
                validation: {
                    required: true,
                    maxLength: 40,
                    isAlphabetical: false
                },
                errorDescriptions: {
                    isMandatoryError: this.props.scriptingJson[constantValues._ERR_MANDATORY_STATE],
                    isLimitExceedError: this.props.scriptingJson[constantValues._ERR_LIMIT_EXCEED_STATE]
                },
                isValid: false,
                touched: false
            }
        } else if ("dropdown" === type) {
            return {
                fieldFormat: 'single',
                fieldType: 'dropdown',
                elementType: 'li',
                elementConfig: {
                    className: 'option'
                },
                options: getStateListFromCountryStateMapping(this.props.scriptingJson?.countryStateMapping, countryCode),
                validation: {
                    required: true
                },
                errorDescriptions: {
                    isMandatoryError: this.props.scriptingJson[constantValues._ERR_MANDATORY_STATE]
                },
                isStateField: true,
                displayValue: '',
                value: '',
                label: this.props.scriptingJson[constantValues._LBL_FORM_STATE],
                isValid: false
            }
        }
    }

    /**
     * This function is used to store the Character provided by user in the dropdown field
     * @param {STRING} {
     *      @elementIdentifier indicates the name of the field with which user interacted
     * }
     * @returns {*|null}
     **/
    dropDownKeyUpHandler = (event, elementIdentifier) => {
        if (/\b(v1)\b/i.test(this.props.componentVersion) && this.props?.componentClassName?.includes("disabledContent")) return;
        const dropDownFormFieldData = this.props.dropDownFormFieldData;
        if (!_.isEmpty(event) && !_.isEmpty(event.key)) {
            if ((_.isEmpty(dropDownFormFieldData) || (!_.isEmpty(dropDownFormFieldData) && event.key.toUpperCase() !== dropDownFormFieldData.searchUserInput)) && !/ARROWUP|ARROWDOWN/i.test(event.key)) {
                this.props.onInitFormDetailUpdateInStore({ "searchUserInput": event.key.toUpperCase(), "elementIdentifier": elementIdentifier + this.state.formType }, "dropDownFormFieldData", false);
            }
            if (/ARROWUP|ARROWDOWN/i.test(event.key)) {
                this.props.onInitFormDetailUpdateInStore({ "searchUserInput": event.key.toUpperCase(), "elementIdentifier": elementIdentifier + this.state.formType, "updateIndex": _.random(0, 10e8), "elementName": elementIdentifier }, "dropDownFormFieldAccess", false);
            }
            if (/TAB|ESCAPE/i.test(event.key) && _.isElement(document.getElementById(`${elementIdentifier}${this.state.formType}Label`))) {
                if (_.isElement(document.getElementById(`${elementIdentifier}Field`)) && /true/i.test(document.getElementById(`${elementIdentifier}${this.state.formType}Label`).getAttribute("aria-expanded"))) {
                    document.getElementById(`${elementIdentifier}Field`).click();
                }
                if (/true/i.test(document.getElementById(`${elementIdentifier}${this.state.formType}Label`).getAttribute("aria-expanded"))) {
                    document.getElementById(`${elementIdentifier}${this.state.formType}Label`).className = "field pl-0 pr-0 alternate dropdown-label bg-soft-grey";
                    document.getElementById(`${elementIdentifier}${this.state.formType}Label`).setAttribute("aria-expanded", "false");
                    document.getElementById(`${elementIdentifier}${this.state.formType}Label`).focus();
                }
            }
        }
    }

    /**
     * This function is used to enable focusIn and focusOut on the dropdown form fields
     * @param {STRING} {
     *      @elementFieldFormat indicates the type of form field i.e., `single` or `multiple`
     *      @elementIdentifier indicates the name of the field with which user interacted
     * }
     * @returns {*|null}
     **/
    dropdownLabelVisibilityHandler = (elementFieldFormat, elementIdentifier) => {
        if (/\b(v1)\b/i.test(this.props.componentVersion) && this.props?.componentClassName?.includes("disabledContent")) return;
        /* close country dropdown on click of state dropdown */
        if (elementIdentifier === "stateOrProvince" && !_.isEmpty(document.getElementById("country" + this.state.formType + "Label"))) {
            document.getElementById("country" + this.state.formType + "Label").classList.remove("focused");
        }
        const dropDownLabelElem = document.getElementById(elementIdentifier + this.state.formType + "Label");
        const dropDownSelectedSpanElem = document.getElementById(elementIdentifier + this.state.formType + "SelectedSpan");
        const dropDownListElement = document.querySelectorAll(`li[data-id=${elementIdentifier + this.state.formType}ListElement]`);
        if (!_.isNull(dropDownLabelElem)) {
            if (dropDownLabelElem.className.search(/focused/) >= 0) {
                dropDownLabelElem.className = "field pl-0 pr-0 alternate dropdown-label bg-soft-grey";
                if (!_.isEmpty(dropDownListElement)) {
                    dropDownListElement.forEach(item => {
                        item.setAttribute("tabIndex", "-1");
                    })
                }
                if (_.isElement(document.getElementById(`${elementIdentifier}${this.state.formType}`))) {
                    document.getElementById(`${elementIdentifier}${this.state.formType}`).setAttribute("aria-hidden", "true");
                    if (_.isElement(document.getElementById(`${elementIdentifier}${this.state.formType}Label`))) {
                        document.getElementById(`${elementIdentifier}${this.state.formType}Label`).setAttribute("aria-expanded", "false");
                    }
                }
                /* execute the validation when focusOut happens on the dropdown field */
                if (!dropDownSelectedSpanElem.innerText) {
                    this.focusOutValidationHandler("", elementFieldFormat, elementIdentifier);
                }
            } else {
                dropDownLabelElem.className = "field pl-0 pr-0 alternate dropdown-label bg-soft-grey focused";
                dropDownListElement[0].focus();
                if (!_.isEmpty(dropDownListElement)) {
                    dropDownListElement.forEach(item => {
                        item.setAttribute("tabIndex", "0")
                    })
                }
                if (_.isElement(document.getElementById(`${elementIdentifier}${this.state.formType}`))) {
                    document.getElementById(`${elementIdentifier}${this.state.formType}`).setAttribute("aria-hidden", "false");
                    if (_.isElement(document.getElementById(`${elementIdentifier}${this.state.formType}Label`)) && !this.props?.componentClassName?.includes("disabledContent")) {
                        document.getElementById(`${elementIdentifier}${this.state.formType}Label`).setAttribute("aria-expanded", "true");
                    }
                }
            }
        }
        document.getElementById(elementIdentifier + this.state.formType).focus();
    }

    /**
     * This function is used to validate the value provided as an input to the HTML form fields
     * @param {STRING|JSON} {
     *      @value contains the value of the interacted HTML form field
     *      @validations contains the validation parameter of the interacted HTML form field
     *      @emptyCheckNotRequired flag to indicate if empty value check is required
     * }
     * @returns {*|JSON}
     **/
    checkFormInputs = (value, validations, emptyCheckNotRequired, elementId) => {
        let validationStatus = {
            validity: true,
            errorType: null
        };
        if (_.isEmpty(validations) || (!_.isEmpty(validations) && !validations.required)) {
            if (validations?.isCustomValidationRequired) {
                validationStatus.validity = validations.customValidation(value, elementId);
                if (!validationStatus.validity) {
                    validationStatus.errorType = "isInvalidError";
                }
            }
            if (validations?.waiveValidation) {
                validationStatus.validity = false;
            }
            if (validations?.addressDigitsCheckFail) {
                validationStatus.validity = false;
                validationStatus.errorType = "isDigitLimitExceedError";
            } 
            return validationStatus;
        } else {
            if (_.isEmpty(value) && emptyCheckNotRequired) {
                validationStatus.validity = false;
                validationStatus.errorType = null;
            }  else if (_.isEmpty(value) && validations.ignoreEmptyValueEmail && validations.emptyCheckNotRequired) {
                validationStatus.validity = false;
                validationStatus.errorType = null;
            } else if (_.isEmpty(value)) {
                validationStatus.validity = false;
                validationStatus.errorType = "isMandatoryError";
                if(validations?.inspicioField){
                    validationStatus.validity = false;
                    validationStatus.errorType = null;
                }
            } else {
                if (validations.maxLength && value.length > validations.maxLength) {
                    validationStatus.validity = false;
                    validationStatus.errorType = "isLimitExceedError";
                } else if (validations.minLength && value.length < validations.minLength) {
                    validationStatus.validity = false;
                    validationStatus.errorType = "isLimitShortError";
                }
                else if (validations.customValidation) {
                    validationStatus.validity = validations.customValidation(value, elementId);
                    if (!validationStatus.validity) {
                        validationStatus.errorType = "isInvalidError";
                    }
                }
                else if (validations.isAlphabetical && !constantValues.IS_ALPHABETICAL_REGEX.test(value)) {
                    validationStatus.validity = false;
                    validationStatus.errorType = "isInvalidError";
                } else if (validations.isEmail && validations.isNewEmail && !validations.isMasked && !constantValues.IS_EMAIL_SIGNUP_REGEX.test(value)) {
                    validationStatus.validity = false;
                    validationStatus.errorType = "isInvalidError";
                }else if ((validations.isEmailExist && this.state.emailAlreadyExist)  || (validations.duplicateCreateAccountEmailIDs?.length && validations.duplicateCreateAccountEmailIDs.includes(value))){
                    validationStatus.validity = false;
                    validationStatus.errorType = "isEmailAlreadyExist";
                } else if (validations.isPassword&&!constantValues.IS_PASSWORD_REGEX.test(value)) {
                    validationStatus.validity = false;
                    validationStatus.errorType = "isInvalidError";
                }else if(validations.isEmail&&!constantValues.IS_EMAIL_REGEX.test(value)){
                    validationStatus.validity = false;
                    validationStatus.errorType = "isInvalidError";
                }else if(validations.isEmail&& validations.isValidRealEmail==false){
                    validationStatus.validity = false;
                    validationStatus.errorType = "validRealEmailError";
                } else if (validations.isCreditCard) {
                    const cardNumberValidation = valid.number(value, { luhnValidateUnionPay: true });
                    if (!cardNumberValidation.isValid) {
                        validationStatus.validity = false;
                        validationStatus.errorType = "isInvalidError";
                    } else if (!_.isNull(cardNumberValidation.card) && cardNumberValidation.card.type.search(new RegExp(this.props.scriptingJson[constantValues.ALLOWED_CREDIT_CARD_REGEX], "i")) <= -1) {
                        validationStatus.validity = false;
                        validationStatus.errorType = "isDifferentCardError";
                    }
                } else if (validations.isAcquisitionCreditCard) {
                    const cardNumberValidation = valid.number(value, { luhnValidateUnionPay: true });
                    if (!cardNumberValidation.isValid) {
                        validationStatus.validity = false;
                        validationStatus.errorType = "isInvalidError";
                    } else if (!_.isNull(cardNumberValidation.card) && cardNumberValidation.card.type.search(new RegExp(this.props.scriptingJson[constantValues.ALLOWED_ACQUISITION_CREDIT_CARD_REGEX], "i")) <= -1) {
                        validationStatus.validity = false;
                        validationStatus.errorType = "isDifferentCardError";
                    }
                } else if (validations.isCardExpiry && !constantValues.IS_CARD_EXPIRY_REGEX.test(value)) {
                    validationStatus.validity = false;
                    validationStatus.errorType = "isInvalidError";
                } else if (validations.isCardExpiry && constantValues.IS_CARD_EXPIRY_REGEX.test(value)) {
                    const monthYearArr = value.split("/");
                    const expirationMonthStatus = valid.expirationMonth(monthYearArr[0]);
                    const expirationYearStatus = valid.expirationYear(monthYearArr[1]);
                    if (!expirationMonthStatus.isValid) {
                        validationStatus.validity = false;
                        validationStatus.errorType = "isInvalidError";
                    } else if (expirationMonthStatus.isValid && expirationYearStatus.isValid && expirationYearStatus.isCurrentYear && !expirationMonthStatus.isValidForThisYear) {
                        validationStatus.validity = false;
                        validationStatus.errorType = "isExpiredError";
                    } else if (expirationMonthStatus.isValid && !expirationYearStatus.isValid) {
                        validationStatus.validity = false;
                        validationStatus.errorType = "isExpiredError";
                    }
                } else if (validations.isLoginEmail) {
                    if (constantValues.IS_MIN_TYPE_REGEX.test(value) || constantValues.IS_SIM_TYPE_REGEX.test(value) || constantValues.IS_ESN_TYPE_REGEX.test(value) || constantValues.IS_EMAIL_REGEX.test(value)) {
                        validationStatus.validity = true;
                        validationStatus.errorType = null;
                    } else {
                        validationStatus.validity = false;
                        validationStatus.errorType = "isInvalidError";
                    }
                } else if (validations.isMinEmailEsnSimAllowed) {
                    if (constantValues.IS_US_FORMATTED_MIN_TYPE_REGEX.test(value) || constantValues.IS_SIM_TYPE_REGEX.test(value) || constantValues.IS_ESN_TYPE_REGEX.test(value) || constantValues.IS_EMAIL_REGEX.test(value)) {
                        validationStatus.validity = true;
                        validationStatus.errorType = null;
                    } else {
                        validationStatus.validity = false;
                        validationStatus.errorType = "isInvalidError";
                    }
                } else if (validations.isMatchPassword) {
                    if (_.isEmpty(this.props.passwordFieldValue)) {
                        validationStatus.validity = false;
                        validationStatus.errorType = "isPasswordMandatoryError";
                    } else if (this.props.passwordFieldValue !== value) {
                        validationStatus.validity = false;
                        validationStatus.errorType = "isInvalidError";
                    }
                } else if (validations.isMatchField) {
                    if (document.getElementById(validations.matchFields[0]).value !== document.getElementById(validations.matchFields[1]).value) {
                        validationStatus.validity = false;
                        validationStatus.errorType = "notMatchError";
                    }
                }
                else if ((validations.matchFields && document.getElementById(validations.matchFields[0]).value === document.getElementById(validations.matchFields[1]).value) && 
                !_.isEmpty(document.getElementById(validations.matchFields[0]).value) && !_.isEmpty(document.getElementById(validations.matchFields[1]).value)) {
                    validationStatus.validity = true;
                    validationStatus.errorType = "";
                }
                else if (validations.onlyDigitsAllowed && !constantValues.IS_DIGITS_ONLY_REGEX.test(value)) {
                    validationStatus.validity = false;
                    validationStatus.errorType = "onlyDigitsAllowedError";
                }
                else if (validations.isNotSameAndSequential && (myAccountDataUtil.isSequentialNumber(value) || constantValues.IS_PIN_HAS_SAME_DIGITS_REGEX.test(value))) {
                    validationStatus.validity = false;
                    validationStatus.errorType = "isNotSameAndSequentialError";
                }
                else if (validations.comparedField) {
                    if (document.getElementById(validations.matchFields[0]).value !== document.getElementById(validations.matchFields[1]).value && 
                    !_.isEmpty(document.getElementById(validations.matchFields[0]).value) && !_.isEmpty(document.getElementById(validations.matchFields[1]).value)) {
                        validationStatus.validity = false;
                        validationStatus.errorType = "notMatchError";
                    }
                    if (document.getElementById(validations.matchFields[0]).value === document.getElementById(validations.matchFields[1]).value && 
                    _.isEmpty(document.getElementById(validations.matchFields[0]).value) && _.isEmpty(document.getElementById(validations.matchFields[1]).value)) {
                        validationStatus.validity = true;
                    }
                }
                else if (validations.isNotSameAndSequential && (myAccountDataUtil.isSequentialNumber(value) || constantValues.IS_PIN_HAS_SAME_DIGITS_REGEX.test(value))) {
                    validationStatus.validity = false;
                    validationStatus.errorType = "isNotSameAndSequentialError";
                } else if (validations.onlyDigitsAllowed && !constantValues.IS_DIGITS_ONLY_REGEX.test(value)) {
                    validationStatus.validity = false;
                    validationStatus.errorType = "onlyDigitsAllowedError";
                } else if (validations.isRafCode && !(/^[a-z0-9A-Z]{4}-{1}[a-z0-9A-Z]{4}$/.test(value))) {
                    validationStatus.validity = false;
                    validationStatus.errorType = "isInvalidError";
                } else if (validations.trackingIdValidation && !constantValues.IS_TRACKID_REGEX.test(value)) {
                    validationStatus.validity = false;
                    validationStatus.errorType = "isInvalidError";
                } else if (validations.billingAddressValidation && !(/^([A-Za-z0-9\W]{1,10})\s+(.+)$/.test(value))) {
                    validationStatus.validity = false;
                    validationStatus.errorType = "isInvalidError";
                }
                else if (validations?.addressDigitsCheckFail) {
                    validationStatus.validity = false;
                    validationStatus.errorType = "isDigitLimitExceedError";
                }
            }
            return validationStatus;
        }
    }

    /**
     * This function is used to validate the form definition provided as an input to the form component
     * @param {STRING|JSON} {
     *      @formDefinition contains entire form definition which will be used to update form state
     * }
     * @returns {*|JSON}
     **/
    getValidatedFormDefinition = (formDefinition) => {
        return !_.isEmpty(formDefinition) && _.isArray(Object.keys(formDefinition)) ?
            Object.keys(formDefinition).map(key => {
                return { "value": formDefinition[key], "key": key };
            }).reduce((result, formElement) => {
                if ("multiple" === formElement.value.fieldFormat) {
                    const updatedFormObjectJson = { ...formElement.value };
                    //eslint-disable-next-line
                    Object.keys(updatedFormObjectJson).forEach(item => {
                        if (_.isObject(updatedFormObjectJson[item])) {
                            const updatedFormElement = {
                                ...updatedFormObjectJson[item]
                            }
                            const validationStatusObj = this.checkFormInputs(updatedFormElement.value, updatedFormElement.validation, true, updatedFormElement?.elementConfig?.id);
                            updatedFormElement.isValid = validationStatusObj.validity;
                            updatedFormElement.errorType = validationStatusObj.errorType;
                            updatedFormObjectJson[item] = updatedFormElement;
                        }
                    });
                    result[formElement.key] = updatedFormObjectJson;
                } else {
                    const updatedFormElement = { ...formElement.value };
                    const validationStatusObj = this.checkFormInputs(updatedFormElement.value, updatedFormElement.validation, true, updatedFormElement?.elementConfig?.id);
                    updatedFormElement.isValid = validationStatusObj.validity;
                    updatedFormElement.errorType = validationStatusObj.errorType;
                    result[formElement.key] = updatedFormElement;
                }
                return result;
            }, {}) : null;
    }

    /**
     * This function is used to validate the entire form HTML fields
     * @param {STRING|JSON} {
     *      @formObject contains the updated form definition object
     * }
     * @returns {*|BOOLEAN}
     **/
    checkFormValidity = (formObject) => {
        let formIsValid = true;
        for (let key in formObject) {
            if ("multiple" === formObject[key].fieldFormat) {
                //eslint-disable-next-line
                Object.keys(formObject[key]).forEach(item => {
                    if (_.isObject(formObject[key][item])) {
                        formIsValid = formObject[key][item].isValid && formIsValid;
                    }
                });
            } else {
                formIsValid = formObject[key].isValid && formIsValid;
                if(formObject[key]?.elementConfig?.id==="createAccountEmail" && this.state.formType === constantValues.FORM_TYPE_CREATE_ACCOUNT){
                    formIsValid = formObject[key]?.validation?.isValidRealEmail;
                }
            }
        }
        return formIsValid;
    }

    /**
     * This function is used to update the city and state field as per the provided zipcode
     * @param {NONE}
     * @returns {*|NONE}
     **/
    updateCityStateFormFields = () => {
        if (this.props.mapQuestFormType === this.state.formType) {
            const formObject = this.state.formDefinition;
            for (let key in formObject) {
                if ("multiple" === formObject[key].fieldFormat) {
                    //eslint-disable-next-line
                    Object.keys(formObject[key]).forEach(item => {
                        if (_.isObject(formObject[key][item])) {
                            if (formObject[key][item].isCityField) {
                                if (!_.isEmpty(this.props.mapQuestCityName)) {
                                    if (formObject[key][item].value !== this.props.mapQuestCityName) {
                                        this.state.updatedZipCode = this.props.mapQuestCityName;
                                    }
                                    formObject[key][item].value = this.props.mapQuestCityName;
                                    formObject[key][item].isValid = true;
                                    formObject[key][item].touched = true;
                                    formObject[key][item].errorType = null;

                                    if(this.props.checkCountryUS && this.props.checkCountryUS==="true" && this.props.mapQuestCountryName){
                                        if(this.props.mapQuestCountryName!=="US"){
                                            formObject[key][item].value = "";
                                            formObject[key][item].isValid = false;
                                            formObject[key][item].touched = false;
                                        }
                                    }
                                    
                                } else {
                                    formObject[key][item].value = "";
                                    formObject[key][item].isValid = false;
                                    formObject[key][item].touched = false;
                                }
                            }
                            if (formObject[key][item].isStateField) {
                                if (!_.isEmpty(this.props.mapQuestStateName)) {
                                    const mapQuestStateName = this.props.mapQuestStateName;
                                    if (mapQuestStateName.length > 2 || !_.isArray(formObject[key][item].options)) {
                                        formObject[key][item].value = mapQuestStateName;
                                        formObject[key][item].displayValue = mapQuestStateName;
                                        formObject[key][item].isValid = true;
                                        formObject[key][item].touched = true;
                                        formObject[key][item].errorType = null;
                                        if(this.props.checkCountryUS && this.props.checkCountryUS==="true" && this.props.mapQuestCountryName){
                                            if(this.props.mapQuestCountryName!=="US"){
                                                formObject[key][item].value = "";
                                                formObject[key][item].displayValue = "";
                                                formObject[key][item].isValid = false;
                                                formObject[key][item].touched = false;
                                            }
                                        }
                                    } else if (_.isArray(formObject[key][item].options)) {
                                        formObject[key][item].value = checkoutDetailDataUtil.getDisplayNameAndValue(mapQuestStateName, formObject[key][item].options, "displayValue", "value");
                                        formObject[key][item].displayValue = checkoutDetailDataUtil.getDisplayNameAndValue(mapQuestStateName, formObject[key][item].options, "value", "displayValue");
                                        formObject[key][item].isValid = true;
                                        formObject[key][item].touched = true;
                                        formObject[key][item].errorType = null;
                                        if(this.props.checkCountryUS && this.props.checkCountryUS==="true" && this.props.mapQuestCountryName){
                                            if(this.props.mapQuestCountryName!=="US"){
                                                formObject[key][item].value = "";
                                                formObject[key][item].displayValue = "";
                                                formObject[key][item].isValid = false;
                                                formObject[key][item].touched = false;
                                            }
                                        }
                                    }
                                } else {
                                    formObject[key][item].value = "";
                                    formObject[key][item].displayValue = "";
                                    formObject[key][item].isValid = false;
                                    formObject[key][item].touched = false;
                                }
                            }
                            if (formObject[key][item].isZipField) {
                                if(this.props.checkCountryUS && this.props.checkCountryUS==="true" && this.props.mapQuestCountryName){
                                    if(this.props.mapQuestCountryName!=="US"){
                                        formObject[key][item].value = "";
                                        formObject[key][item].isValid = false;
                                        formObject[key][item].touched = false;
                                    }
                                }
                            }
                        }
                    });
                } else {
                    if (formObject[key].isCityField) {
                        if (!_.isEmpty(this.props.mapQuestCityName)) {
                            formObject[key].value = this.props.mapQuestCityName;
                            formObject[key].isValid = true;
                            formObject[key].touched = true;
                            formObject[key].errorType = null;

                            if(this.props.checkCountryUS && this.props.checkCountryUS==="true" && this.props.mapQuestCountryName){
                                if(this.props.mapQuestCountryName!=="US"){
                                    formObject[key].value = "";
                            formObject[key].isValid = false;
                            formObject[key].touched = false;
                                }
                            }
                        } else {
                            formObject[key].value = "";
                            formObject[key].isValid = false;
                            formObject[key].touched = false;
                        }
                    }
                    if (formObject[key].isStateField) {
                        if (!_.isEmpty(this.props.mapQuestStateName)) {
                            const mapQuestStateName = this.props.mapQuestStateName;
                            if (mapQuestStateName.length > 2 || !_.isArray(formObject[key].options)) {
                                formObject[key].value = mapQuestStateName;
                                formObject[key].displayValue = mapQuestStateName;
                                formObject[key].isValid = true;
                                formObject[key].touched = true;
                                formObject[key].errorType = null;
                                if(this.props.checkCountryUS && this.props.checkCountryUS==="true" && this.props.mapQuestCountryName){
                                    if(this.props.mapQuestCountryName!=="US"){
                                        formObject[key].value = "";
                                        formObject[key].displayValue = "";
                                        formObject[key].isValid = false;
                                        formObject[key].touched = false;
                                    }
                                }
                            } else if (_.isArray(formObject[key].options)) {
                                formObject[key].value = checkoutDetailDataUtil.getDisplayNameAndValue(mapQuestStateName, formObject[key].options, "displayValue", "value");
                                formObject[key].displayValue = checkoutDetailDataUtil.getDisplayNameAndValue(mapQuestStateName, formObject[key].options, "value", "displayValue");
                                formObject[key].isValid = true;
                                formObject[key].touched = true;
                                formObject[key].errorType = null;
                                if(this.props.checkCountryUS && this.props.checkCountryUS==="true" && this.props.mapQuestCountryName){
                                    if(this.props.mapQuestCountryName!=="US"){
                                        formObject[key].value = "";
                                        formObject[key].displayValue = "";
                                        formObject[key].isValid = false;
                                        formObject[key].touched = false;
                                    }
                                }
                            }
                        } else {
                            formObject[key].value = "";
                            formObject[key].displayValue = "";
                            formObject[key].isValid = false;
                            formObject[key].touched = false;
                        }
                    }
                }
            }
            /* reset mapQuestData data in store */
            this.props.onInitFormDetailUpdateInStore({
                stateName: null,
                cityName: null,
                countryName:null,
                formType: null,
                mapQuestApiErrorMessage: null
            }, "mapQuestData", false);
            /* updated city and state data in respective form object */
            if (!_.isEmpty(formObject['zip_city']['zipCode']?.value) &&_.isEmpty(formObject['addressLine1']?.value) && formObject['zip_city']['zipCode']?.validation?.isAddressReq) {
                formObject['addressLine1'].isValid = false;
                formObject['addressLine1'].errorType = "isMandatoryError";
            }
            this.props.onInitFormDetailUpdateInStore(this.getUpdatedFormFieldValues(formObject), this.state.formType, false);
        }
    }

    /**
     * This function is used to enable or disable the zipcode length restriction based on selected country
     * @param {BOOLEAN|OBJECT} {
     *      @isZipRestrictionRequired contains the boolean value to indicate whether zip length restriction is required.
     *      @formObject contains the latest form definition object
     * }
     * @returns {*|NONE}
     **/
    updateZipCodeLengthRestriction = (isZipRestrictionRequired, formObject) => {
        for (let key in formObject) {
            if ("multiple" === formObject[key].fieldFormat) {
                //eslint-disable-next-line
                Object.keys(formObject[key]).forEach(item => {
                    if (_.isObject(formObject[key][item]) && formObject[key][item].isZipField) {
                        /* reset the zip field value, remove success icon and error note when the country is changed */
                        formObject[key][item].value = "";
                        formObject[key][item].isValid = false;
                        formObject[key][item].touched = false;
                        formObject[key][item].errorType = null;
                        if (isZipRestrictionRequired) {
                            formObject[key][item].validation.maxLength = 5;
                            formObject[key][item].validation.minLength = 5;
                            formObject[key][item].elementConfig.onKeyPress = (event) => { return (event.charCode > 47 && event.charCode < 58) ? true : event.preventDefault() }
                        } else {
                            formObject[key][item].validation.maxLength = null;
                            formObject[key][item].validation.minLength = null;
                            formObject[key][item].elementConfig.onKeyPress = null;
                        }
                    }
                });
            } else {
                if (formObject[key].isZipField) {
                    /* reset the zip field value, remove success icon and error note when the country is changed */
                    formObject[key].value = "";
                    formObject[key].isValid = false;
                    formObject[key].touched = false;
                    formObject[key].errorType = null;
                    if (isZipRestrictionRequired) {
                        formObject[key].validation.maxLength = 5;
                        formObject[key].validation.minLength = 5;
                    } else {
                        formObject[key].validation.maxLength = null;
                        formObject[key].validation.minLength = null;
                        formObject[key].elementConfig.onKeyPress = null;
                    }
                }
            }
        }
    }

    /**
     * This function is used to update the credit card CVV limit
     * @param {STRING|OBJECT} {
     *      @creditCardBrand contains the name of the credit card vendor
     *      @formObject contains the latest form definition object
     * }
     * @returns {*|NONE}
     **/
    updateCreditCardCVVLimit = (creditCardBrand, formObject, isReset) => {
        const creditCardCVVLimit = checkoutDetailDataUtil.getCreditCardCVVLimit(creditCardBrand);
        for (let key in formObject) {
            if ("multiple" === formObject[key].fieldFormat) {
                //eslint-disable-next-line
                Object.keys(formObject[key]).forEach(item => {
                    if (_.isObject(formObject[key][item]) && formObject[key][item].isNewCardCVV) {
                        if (isReset) {
                            formObject[key][item].validation.maxLength = creditCardCVVLimit;
                            formObject[key][item].validation.minLength = creditCardCVVLimit;
                        } else {
                            formObject[key][item].value = "";
                            formObject[key][item].isValid = false;
                            formObject[key][item].validation.maxLength = creditCardCVVLimit;
                            formObject[key][item].validation.minLength = creditCardCVVLimit;
                        }
                    }
                });
            } else {
                if (formObject[key].isNewCardCVV) {
                    if (isReset) {
                        formObject[key].validation.maxLength = creditCardCVVLimit;
                        formObject[key].validation.minLength = creditCardCVVLimit;
                    }
                    else {
                        formObject[key].value = "";
                        formObject[key].isValid = false;
                        formObject[key].validation.maxLength = creditCardCVVLimit;
                        formObject[key].validation.minLength = creditCardCVVLimit;
                    }
                }
            }
        }
    }

    /**
     * This function is used to validate the entire form HTML fields
     * @param {STRING|JSON} {
     *      @formObject contains the updated form definition object
     * }
     * @returns {*|BOOLEAN}
     **/
    getUpdatedFormFieldValues = (formObject) => {
        let formFieldJson = {};
        for (let key in formObject) {
            if ("multiple" === formObject[key].fieldFormat) {
                //eslint-disable-next-line
                Object.keys(formObject[key]).forEach(item => {
                    if (_.isObject(formObject[key][item])) {
                        formFieldJson[item] = {};
                        formFieldJson[item]["value"] = formObject[key][item].value;
                        formFieldJson[item]["isValid"] = formObject[key][item].isValid;
                    }
                });
            } else {
                formFieldJson[key] = {};
                formFieldJson[key]["value"] = formObject[key].value;
                formFieldJson[key]["isValid"] = formObject[key].isValid;
                if(formObject[key]?.elementConfig?.id==="createAccountEmail" && this.state.formType === constantValues.FORM_TYPE_CREATE_ACCOUNT){
                    formFieldJson[key]["isValidRealEmail"] = formObject[key]?.validation?.isValidRealEmail;
                    formFieldJson[key]["validRealEmailError"] = formObject[key]?.errorDescriptions?.validRealEmailError;
                    if(!formObject[key]?.validation?.isValidRealEmail){
                        formFieldJson[key]["isValid"] = false;
                    }
                    if(formObject[key]?.validation?.isMasked){
                        formFieldJson[key]["isValid"] = true;
                    }
                }
            }
        }
        return formFieldJson;
    }

    /**
     * This function is used to validate the entire form HTML fields
     * @param {STRING|JSON} {
     *      @formObject contains the updated form definition object
     * }
     * @returns {*|BOOLEAN}
     **/
    getCountryIdentifier = (formObject) => {
        let countryIdentifier = "";
        for (let key in formObject) {
            if ("multiple" === formObject[key].fieldFormat) {
                //eslint-disable-next-line
                Object.keys(formObject[key]).forEach(item => {
                    if (_.isObject(formObject[key][item]) && formObject[key][item].isCountryField) {
                        countryIdentifier = !_.isEmpty(formObject[key][item].value) ? formObject[key][item].value : "";
                    }
                });
            } else {
                if (formObject[key].isCountryField) {
                    countryIdentifier = !_.isEmpty(formObject[key].value) ? formObject[key].value : "";
                }
            }
        }
        return countryIdentifier;
    }

    /**
     * This function is used to display the entered password/masked field
     * @param {STRING} {
     *      @identifier contains the identifier of the input field for which password is to be displayed
     * }
     * @returns {*|NONE}
     **/
    passwordFieldDisplayHandler = (identifier) => {
        if (document.getElementById(identifier).type === "password") {
            document.getElementById(identifier).type = "text";
            if (identifier === 'leaseSSN4') {
                document.getElementById(identifier).type = "number";
            }
            if (!_.isEmpty(document.getElementsByName(`${identifier}Anchor`))) {
                document.getElementsByName(`${identifier}Anchor`)[0].setAttribute("aria-label", `${this.props.scriptingJson[constantValues._LBL_FORM_PASSWORD_WITHOUT_ASTRIK]} shown ${this.props.scriptingJson[constantValues._LNK_HIDE]} ${this.props.scriptingJson[constantValues._LBL_FORM_PASSWORD_WITHOUT_ASTRIK]}`)
                document.getElementsByName(`${identifier}Anchor`)[0].innerText = this.props.scriptingJson[constantValues._LNK_HIDE];
            }
        } else {
            document.getElementById(identifier).type = "password";
            if (!_.isEmpty(document.getElementsByName(`${identifier}Anchor`))) {
                document.getElementsByName(`${identifier}Anchor`)[0].setAttribute("aria-label", `${this.props.scriptingJson[constantValues._LBL_FORM_PASSWORD_WITHOUT_ASTRIK]} hidden ${this.props.scriptingJson[constantValues._LNK_VIEW]} ${this.props.scriptingJson[constantValues._LBL_FORM_PASSWORD_WITHOUT_ASTRIK]}`)
                document.getElementsByName(`${identifier}Anchor`)[0].innerText = this.props.scriptingJson[constantValues._LNK_VIEW];
            }
        }
    }

    /**
     * This function is executed when an input is provided to the HTML form field
     * @param {STRING|JSON} {
     *      @event contains either the HTML form field target or the entered value
     *      @elementFieldFormat indicates the type of form field i.e., `single` or `multiple`
     *      @elementIdentifier indicates the name of the field with which user interacted
     *      @subElementIdentifier indicates the name of the field with which user interacted in case the field of multiple format
     * }
     * @returns {*|NONE} updates the class state formDefinition object
     **/
    inputChangedHandler = (event, elementFieldFormat, elementIdentifier, subElementIdentifier, elementOptions, skipOnChangeValidation,isCheckoutShippingZip) => {
        let enteredValue = _.isString(event) ? event : event.target.value;
        let updatedFormDefinition = {
            ...this.state.formDefinition
        }

        if(elementIdentifier === 'emailAddress') {
            this.state.emailAlreadyExist = false;
        }
        if(elementIdentifier === 'zip_city') {
            this.props.resetMarketSegmentError()
            this.props.editShippingMarketSegmentErrorHandler("")
        }
        if ((["cardNumber", "cardExpiry", "cardCVV"].includes(elementIdentifier) || (elementFieldFormat === 'single' && elementIdentifier==='creditCard')) && this.props.updateCreditCardDataNotifier) {
            this.props.updateCreditCardDataNotifier(elementIdentifier);
        }

        

        const dropDownLabelSpanElem = document.getElementById(elementIdentifier + this.state.formType + "LabelSpan");
        const dropDownSelectedSpanElem = document.getElementById(elementIdentifier + this.state.formType + "SelectedSpan");
        if (!_.isNull(dropDownSelectedSpanElem) && !_.isEmpty(event) && _.isString(event)) {
            if (!_.isNull(dropDownLabelSpanElem)) {
                dropDownLabelSpanElem.className = "place-holder-selected";
            }
            dropDownSelectedSpanElem.innerText = checkoutDetailDataUtil.getDisplayNameAndValue(event, elementOptions, "value", "displayValue");
        }

        if (updatedFormDefinition[elementIdentifier]?.isStateFieldToggleRequired) {
            const stateFieldKey = _.findKey(updatedFormDefinition, function (formDefinitionJson) { return formDefinitionJson.isStateField; });
            const countryDisplayValue = checkoutDetailDataUtil.getDisplayNameAndValue(event, elementOptions, "value", "displayValue");
            /* toggle the state field between dropdown format and textbox format */
            if (countryDisplayValue.search(new RegExp(this.props.scriptingJson[constantValues.STATE_TOGGLE_COUNTRIES_REGEX], "i")) >= 0) {
                const stateSelectedSpanElem = document.getElementById("state" + this.state.formType + "SelectedSpan");
                const countryCode = (findRequestedObject(constantValues.COUNTRY_LIST, countryDisplayValue, "displayValue") || {}).value;
                /* refresh the state label span */
                if (!_.isNull(stateSelectedSpanElem)) {
                    stateSelectedSpanElem.innerText = "";
                }
                updatedFormDefinition[stateFieldKey] = this.getNewStateFieldDefinition("dropdown", countryCode);
            } else {
                updatedFormDefinition[stateFieldKey] = this.getNewStateFieldDefinition("textbox");
            }
            /* enable or disable the zipcode restriction based on selected country */
            if (countryDisplayValue.search(new RegExp(this.props.scriptingJson[constantValues.ZIP_RESTRICTED_COUNTRIES_REGEX], "i")) >= 0) {
                this.updateZipCodeLengthRestriction(true, updatedFormDefinition);
            } else {
                this.updateZipCodeLengthRestriction(false, updatedFormDefinition);
            }
        }

        let updatedFormElement = null;
        if ("multiple" === elementFieldFormat) {
            const updatedFormObjectJson = {
                ...updatedFormDefinition[elementIdentifier]
            }
            updatedFormElement = {
                ...updatedFormObjectJson[subElementIdentifier]
            }
            /* fetching and providing the credit card type */
            if (updatedFormElement.validation.isCreditCard || updatedFormElement.validation.isAcquisitionCreditCard) {
                const creditCardBrandName = checkoutDetailDataUtil.getCreditCardBrandName(enteredValue);
                if (!_.isEmpty(creditCardBrandName)) {
                    this.props.updateCreditCardVendorIconHandler(creditCardBrandName);
                } else {
                    this.props.updateCreditCardVendorIconHandler(null);
                }
            }

            /*updating the corresponding formElement JSON immutably */
            if (updatedFormElement.validation) {
                const validationStatusObj = this.checkFormInputs(enteredValue, updatedFormElement.validation, undefined, updatedFormElement?.elementConfig?.id);
                updatedFormElement.isValid = validationStatusObj.validity;
                //updatedFormElement.errorType = validationStatusObj.errorType;
            }

            /*updating the corresponding formElement JSON immutably */
            
            updatedFormElement.value = enteredValue;
            updatedFormElement.touched = true;

            /* Format the phone number in USA format */
            if (updatedFormElement.isPhoneField) {
                let phoneNumber = updatedFormElement.value;
                const input = phoneNumber.replace(/\D/g, '').substring(0, 10); // First ten digits of input only
                const zip = input.substring(0, 3), middle = input.substring(3, 6), last = input.substring(6, 10);

                if (input.length > 6) { phoneNumber = `(${zip}) ${middle} ${last}`; }
                else if (input.length > 3) { phoneNumber = `(${zip}) ${middle}`; }
                else if (input.length > 0) { phoneNumber = `(${zip}`; }
                updatedFormElement.value = phoneNumber;
            }
            /* Format the Zip Code if pasted */
            if (updatedFormElement.isCheckoutShippingZip) {
                let zipentered = updatedFormElement.value;
                var input = zipentered
                if(input === ""){
                    const secondFormElement = {
                        ...updatedFormObjectJson["city"]
                    }
                    const validationStatusObj = this.checkFormInputs("", secondFormElement.validation, undefined, secondFormElement?.elementConfig?.id);
                    secondFormElement.isValid = validationStatusObj.validity;

                    secondFormElement.value = "";
                    // secondFormElement.touched = true;
                    updatedFormObjectJson["city"] = secondFormElement;
                }
                if(zipentered.length >5){
                input = zipentered.replace(/\D/g, '').substring(0, 5); 
                }
                updatedFormElement.value = input;
            }
            /* Format the card expiry in MM/YY format */
            if (updatedFormElement.isCardExpiryField) {
                let cardExpiry = updatedFormElement.value;
                const input = cardExpiry.replace(/\D/g, '').substring(0, 4); // First 4 digits of input only
                const month = input.substring(0, 2), year = input.substring(2, 4)
                if (input.length > 2) { cardExpiry = `${month}/${year}` }
                updatedFormElement.value = cardExpiry;
            }
            if (updatedFormElement.isCityField) {
                this.state.updatedZipCode = false;
            }

            updatedFormObjectJson[subElementIdentifier] = updatedFormElement;
            updatedFormDefinition[elementIdentifier] = updatedFormObjectJson;
        } else {
            updatedFormElement = {
                ...updatedFormDefinition[elementIdentifier]
            }
            /* fetching and providing the credit card type */
            if (updatedFormElement.validation.isCreditCard || updatedFormElement.validation.isAcquisitionCreditCard) {
                const creditCardBrandName = checkoutDetailDataUtil.getCreditCardBrandName(enteredValue);
                if (!_.isEmpty(creditCardBrandName)) {
                    this.props.updateCreditCardVendorIconHandler(creditCardBrandName);
                } else {
                    this.props.updateCreditCardVendorIconHandler(null);
                }
                /* Update the credit card CVV limit */
                this.updateCreditCardCVVLimit(creditCardBrandName, updatedFormDefinition);
            }

            /* Updating the corresponding formElement JSON immutably */
            updatedFormElement.value = enteredValue;
            /* switching touched parameter for checkbox/toggle field type */
            if ("checkbox" === updatedFormElement.fieldType || "toggle" === updatedFormElement.fieldType) {
                if (updatedFormElement.touched) {
                    updatedFormElement.touched = false;
                    updatedFormElement.value = "";
                } else {
                    updatedFormElement.touched = true;
                    updatedFormElement.value = "checked";
                }
            } else {
                updatedFormElement.touched = true;
            }

            /*updating the corresponding formElement JSON immutably */
            if (updatedFormElement.validation) {
                const validationStatusObj = this.checkFormInputs(updatedFormElement.value, updatedFormElement.validation, undefined, updatedFormElement?.elementConfig?.id);
                updatedFormElement.isValid = validationStatusObj.validity;
                //updatedFormElement.errorType = validationStatusObj.errorType;
            }

            /* check for valid raf code alphanumeric-alphanumeric*/
            if (updatedFormElement.validation.isRafCode) {
                let rafCode = updatedFormElement.value;
                updatedFormElement.isValid = /^[a-z0-9A-Z]{4}-{1}[a-z0-9A-Z]{4}$/.test(rafCode);
            }

            /* since state is a dropdown field, hence update the validity status when onChange event occur */
            if ("dropdown" === updatedFormElement.fieldType) {
                if (!_.isEmpty(enteredValue)) {
                    updatedFormElement.value = enteredValue;
                    updatedFormElement.displayValue = checkoutDetailDataUtil.getDisplayNameAndValue(enteredValue, updatedFormElement.options, "value", "displayValue");
                    updatedFormElement.isValid = true;
                    updatedFormElement.errorType = null;
                    if(document.getElementById(`${elementIdentifier}${this.state.formType}Label`)){
                        document.getElementById(`${elementIdentifier}${this.state.formType}Label`).focus();
                    }
                    if(elementIdentifier === 'nickName') {
                        this.props.resetMarketSegmentError();
                    }
                } else {
                    updatedFormElement.isValid = false;
                    updatedFormElement.errorType = "isMandatoryError";
                }
            }
            /* Format the phone number in USA format */
            if (updatedFormElement.isPhoneField) {
                let phoneNumber = updatedFormElement.value;
                const input = phoneNumber.replace(/\D/g, '').substring(0, 10); // First ten digits of input only
                const zip = input.substring(0, 3), middle = input.substring(3, 6), last = input.substring(6, 10);

                if (input.length > 6) { phoneNumber = `(${zip}) ${middle} ${last}`; }
                else if (input.length > 3) { phoneNumber = `(${zip}) ${middle}`; }
                else if (input.length > 0) { phoneNumber = `(${zip}`; }
                updatedFormElement.value = phoneNumber;
            }

            /* Format the card number */
            if (updatedFormElement.isCardNumberField) {
                let cardNumber = updatedFormElement.value;
                const input = cardNumber.replace(/\D/g,'');
                const first = input.substring(0,4), second = input.substring(4,8), third = input.substring(8,12), fourth = input.substring(12,16), fifth = input.substring(16,19);

                if(input.length > 16){cardNumber = `${first} ${second} ${third} ${fourth} ${fifth}`;}
                else if(input.length > 12){cardNumber = `${first} ${second} ${third} ${fourth}`;}
                else if(input.length > 8){cardNumber = `${first} ${second} ${third}`;}
                else if(input.length > 4){cardNumber = `${first} ${second}`;}
                else if(input.length > 0){cardNumber = `${first}`;}
                updatedFormElement.value = cardNumber;
            }
            if (updatedFormElement.elementConfig.type === "tel") {
                updatedFormElement.isValid = updatedFormElement.value.length === 14 ? true : false
            }
            if (updatedFormElement.elementConfig.type === "email") {
                updatedFormElement.isValid = updatedFormElement.value.match(constantValues.IS_EMAIL_REGEX) ? true : false
            }
            updatedFormDefinition[elementIdentifier] = updatedFormElement;

            /* store the state field detail in redux store */
            if (updatedFormElement.isStateField || "checkbox" === updatedFormElement.fieldType || "toggle" === updatedFormElement.fieldType || "gifttextarea" === updatedFormElement.fieldType) {
                this.props.onInitFormDetailUpdateInStore(this.getUpdatedFormFieldValues(updatedFormDefinition), this.state.formType, false);
            }
            if ("dropdown" === updatedFormElement.fieldType) {
                this.props.onInitFormDetailUpdateInStore({ "searchUserInput": null, "elementIdentifier": null, "elementName": null }, "dropDownFormFieldAccess", false);
            }
        }

        /*check the form validity */
        let formIsValid = this.checkFormValidity(updatedFormDefinition);
        if (formIsValid || skipOnChangeValidation) {
            this.props.onInitFormDetailUpdateInStore(this.getUpdatedFormFieldValues(updatedFormDefinition), this.state.formType, false);
        }

        /* set the state with updated shipping form details and form validity status */
        this.setState({
            formDefinition: updatedFormDefinition,
            formIsValid: formIsValid
        });

        const e = {};
        Object.assign(e,event);
        setTimeout(()=>{
            if(isCheckoutShippingZip){
                enteredValue = enteredValue.length >5 ? enteredValue.substring(0,5) : enteredValue;
                this.focusOutValidationHandler(e, elementFieldFormat, elementIdentifier, subElementIdentifier)
            }
        },1000)
    }

    /**
     * This function is executed when focusOut happens after providing value to the HTML form field or onBlur event on the form fields
     * @param {STRING|JSON} {
     *      @event contains either the HTML form field target or the entered value
     *      @elementFieldFormat indicates the type of form field i.e., `single` or `multiple`
     *      @elementIdentifier indicates the name of the field with which user interacted
     *      @subElementIdentifier indicates the name of the field with which user interacted in case the field of multiple format
     * }
     * @returns {*|NONE} updates the class state formDefinition object
     **/
    focusOutValidationHandler = (event, elementFieldFormat, elementIdentifier, subElementIdentifier) => {
        let enteredValue = _.isString(event) ? event : event.target.value, updatedFormElement = null;
        let updatedFormDefinition = {
            ...this.state.formDefinition
        }

        if ("multiple" === elementFieldFormat) {
            const updatedFormObjectJson = {
                ...updatedFormDefinition[elementIdentifier]
            }
            updatedFormElement = {
                ...updatedFormObjectJson[subElementIdentifier]
            }

            /* fetching and providing the credit card type */
            if (updatedFormElement.validation.isCreditCard || updatedFormElement.validation.isAcquisitionCreditCard) {
                const creditCardBrandName = checkoutDetailDataUtil.getCreditCardBrandName(enteredValue);
                if (!_.isEmpty(creditCardBrandName)) {
                    this.props.updateCreditCardVendorIconHandler(creditCardBrandName);
                } else {
                    this.props.updateCreditCardVendorIconHandler(null);
                }
            }

            /*updating the corresponding formElement JSON immutably */
            if (updatedFormElement.validation) {
                const validationStatusObj = this.checkFormInputs(enteredValue, updatedFormElement.validation, undefined, updatedFormElement?.elementConfig?.id);
                updatedFormElement.isValid = validationStatusObj.validity;
                updatedFormElement.errorType = validationStatusObj.errorType;
            }

            /* fetch city and state using the zipcode and save in store */
            if (updatedFormElement.isZipField && updatedFormElement.isValid) {
                /* update city and state if zip field is valid */
                const mapQuestApiUrl = this.props.scriptingJson[constantValues.MAP_QUEST_END_POINT_URL] + this.props.scriptingJson[constantValues.MAP_QUEST_API_PATH] + `?key=${this.props.scriptingJson[constantValues.MAP_QUEST_AUTH_TOKEN]}&location=${enteredValue},${this.getCountryIdentifier(updatedFormDefinition)}&outFormat=json&maxResults=1`;
                this.props.onInitUpdateCityStateInStore(mapQuestApiUrl, this.state.formType);
            }
            /* Set touched to false if no value is provided */
            if (_.isEmpty(updatedFormElement.value)) {
                updatedFormElement.touched = false;
            }

            updatedFormObjectJson[subElementIdentifier] = updatedFormElement;
            updatedFormDefinition[elementIdentifier] = updatedFormObjectJson;
        } else {
            updatedFormElement = {
                ...updatedFormDefinition[elementIdentifier]
            }

            /* fetching and providing the credit card type */
            if (updatedFormElement.validation.isCreditCard || updatedFormElement.validation.isAcquisitionCreditCard) {
                const creditCardBrandName = checkoutDetailDataUtil.getCreditCardBrandName(enteredValue);
                if (!_.isEmpty(creditCardBrandName)) {
                    this.props.updateCreditCardVendorIconHandler(creditCardBrandName);
                } else {
                    this.props.updateCreditCardVendorIconHandler(null);
                }
            }

            /*updating the corresponding formElement JSON immutably */
            if (updatedFormElement.validation) {
                const validationStatusObj = this.checkFormInputs(enteredValue, updatedFormElement.validation, undefined, updatedFormElement?.elementConfig?.id);
                updatedFormElement.isValid = validationStatusObj.validity;
                updatedFormElement.errorType = validationStatusObj.errorType;
            }

            /* fetch city and state using the zipcode and save in store */
            if (updatedFormElement.isZipField && updatedFormElement.isValid) {
                /* update city and state if zip field is valid */
                const mapQuestApiUrl = this.props.scriptingJson[constantValues.MAP_QUEST_END_POINT_URL] + this.props.scriptingJson[constantValues.MAP_QUEST_API_PATH] + `?key=${this.props.scriptingJson[constantValues.MAP_QUEST_AUTH_TOKEN]}&location=${enteredValue},${this.getCountryIdentifier(updatedFormDefinition)}&outFormat=json&maxResults=1`;
                this.props.onInitUpdateCityStateInStore(mapQuestApiUrl, this.state.formType);
            }
            /**to add aria live on focus */
            if (updatedFormElement.live) {
                updatedFormElement.showAriaLive = true;
            }

            /* Set touched to false if no value is provided */
            if (_.isEmpty(updatedFormElement.value)) {
                updatedFormElement.touched = false;
            }
            /* set touched to true for special input fields */
            if (updatedFormElement.isAlwaysTouched) {
                updatedFormElement.touched = true;
            }

            /* check for valid raf code alphanumeric-alphanumeric*/
            if (updatedFormElement.validation.isRafCode) {
                let rafCode = updatedFormElement.value;
                updatedFormElement.isValid = /^[a-z0-9A-Z]{4}-{1}[a-z0-9A-Z]{4}$/.test(rafCode);
            }

            if(this.props.scriptingJson[constantValues.ENABLE_ACCOUNT_CREATION_VALIDATION] === "true" && updatedFormElement?.elementConfig?.id==="createAccountEmail" && this.state.formType === constantValues.FORM_TYPE_CREATE_ACCOUNT){
               if(updatedFormElement.errorType==="validRealEmailError"){
                    updatedFormElement.errorType = null;
                    updatedFormElement.isValid = true;
                    updatedFormElement.validation.isValidRealEmail =true;
                }
            }
             // address validation
             if (elementIdentifier == 'addressLine1' || elementIdentifier == 'addressLine2') {
                if (!_.isEmpty(enteredValue)) {
                    const addressDigitsCheckFail = checkoutDetailDataUtil.hasMoreThanRequiredContinuousDigits(!_.isEmpty(enteredValue) ? enteredValue : '', this.props.scriptingJson[constantValues._SHIPPING_ADDRESS_ALLOWED_DIGITS])
                    if (addressDigitsCheckFail) {
                        updatedFormElement.isValid = false;
                        updatedFormElement.errorType = "isDigitLimitExceedError";
                    }
                }
            }
            updatedFormDefinition[elementIdentifier] = updatedFormElement;
        }

        /*check the form validity */
        let formIsValid = this.checkFormValidity(updatedFormDefinition);

        /* store the form detail in redux store when form is successfully validated */
        this.props.onInitFormDetailUpdateInStore(this.getUpdatedFormFieldValues(updatedFormDefinition), this.state.formType, false);

        /* set the state with updated shipping form details and form validity status */
        this.setState({
            formDefinition: updatedFormDefinition,
            formIsValid: formIsValid
        });
    }

    inputFocus = (live, key) => {
        /**
         * if aria live announcement is required for the input
         */
        if (live) {
            const updatedFormDefinition = {
                ...this.state.formDefinition,
            };

            updatedFormDefinition[key] = {
                ...updatedFormDefinition[key],
                showAriaLive: false,
            }

            this.setState((state) => ({
                ...state,
                formDefinition: updatedFormDefinition,
            }));
        }
    }

    addErrorForBtnAccessibility(formElementObj, ariaDescribedByArr) {
        if (this.props.addFormErrorsBtnAccessibility) {
            let errorText = formElementObj.errorDescriptions[formElementObj.errorType];
            if (_.isEmpty(errorText) && !formElementObj.isValid && _.isEmpty(formElementObj.value) && formElementObj.validation?.required && formElementObj.errorDescriptions?.isMandatoryError) {
                errorText = formElementObj.errorDescriptions?.isMandatoryError;
            }
            if (!_.isEmpty(errorText)) ariaDescribedByArr.push(`${formElementObj.label} ${constantValues._LBL_ERROR} ${errorText}`);
        }
        return true;
    }

    render() {
        const isNewImplementation = /STRAIGHT_TALK/i.test(this.props.scriptingJson[constantValues.API_BRAND_NAME]);
        /* update the city field and state field based on zipcode */
        if (!_.isNull(this.props.mapQuestCityName) || !_.isNull(this.props.mapQuestStateName)) {
            this.state.updatedZipCode = false;
            this.updateCityStateFormFields();
        }
        let formClass = "";
        const ariaDescribedByArr = [];

        const formElementsArray = [];
        for (let key in this.state.formDefinition) {
            formElementsArray.push({
                id: key,
                config: this.state.formDefinition[key]
            });
        }
        if (this.state.formType == constantValues.FORM_TYPE_RAF_CODE) {
            formClass = "row";
        }

        const formStructure = formElementsArray.map(formElement => {
            let FormDefinitionElem = null;
            if ("single" === formElement.config.fieldFormat && "textbox" === formElement.config.fieldType && (_.isUndefined(formElement.config.isLoggedInUserField) || this.props.isLoggedIn === formElement.config.isLoggedInUserField)) {
                /* determine input group class name based on various parameter */
                let inputGroupClassName = `col-12 pb-10 pl-0 pr-0 ${this.props?.formDefinition?.userInput?.className ? this.props?.formDefinition?.userInput?.className : ``}`;
                if (formElement.config.isDisabled) {
                    inputGroupClassName = "col-12 pb-10 pl-0 pr-0 disabled";
                } else if (formElement.config.isHidden) {
                    inputGroupClassName = "col-12 pb-10 pl-0 pr-0 d-none";
                } else if (formElement.config.isOTPField && this.props.hideOtpField) {
                    inputGroupClassName = "col-12 pb-10 pl-0 pr-0 d-none";
                } else if (formElement.config.isPhoneField && this.props.hidePhoneNumberField) {
                    inputGroupClassName = "col-12 pb-10 pl-0 pr-0 d-none";
                }
                else if (this.state.formType == constantValues.FORM_TYPE_RAF_CODE) {
                    inputGroupClassName = "col-12 col-sm-5";
                }
                let inputClassName = '';
                if (formElement?.config?.elementConfig?.isDisabledField) {
                    inputClassName = formElement.config.elementConfig.className;
                } else {
                  inputClassName = formElement.config.isValid && formElement.config.touched ? formElement.config.elementConfig.className + " success" : formElement.config.elementConfig.className;
                }
                inputClassName = formElement.config.errorType && !formElement.config.isValid ? `${inputClassName} error` : inputClassName;
                if (formElement.config.elementConfig.type === "tel" && formElement.config.value === "") {
                    inputClassName = formElement.config.elementConfig.className
                } else if (formElement.config.elementConfig.type === "email" && formElement.config.value === "") {
                    inputClassName = inputClassName ?inputClassName:formElement.config.elementConfig.className
                }

                if (formElement.config?.eitherOr) {
                    formElement.config.validation.required = true;
                    let firstElem = formElementsArray.filter(function (value) { return value.config.element == 'first' });
                    let secondElem = formElementsArray.filter(function (value) { return value.config.element == 'second' });

                    if (secondElem[0].config.isValid) {
                        firstElem[0].config.validation.required = false;
                        firstElem[0].config.validation.waiveValidation = true;
                    } else if (firstElem[0].config.isValid) {
                        secondElem[0].config.validation.required = false;
                        secondElem[0].config.validation.waiveValidation = true;
                    }
                }
                FormDefinitionElem = (
                    <div className={inputGroupClassName} key={formElement.id}>
                        <div className="md-form input-group alternate bg-soft-grey mt-0 mb-0">
                            {formElement.config.tooltipContent ?
                                <><div className="textbox-tooltip-label">
                                    <label htmlFor={formElement.config.elementConfig.name} className={formElement.config.value || formElement.config.touched ? "checkoutLabel active" : "checkoutLabel"}>{formElement.config.label}</label>
                                    {formElement.config.tooltipContent ?
                                        <Tooltip
                                            id={`${formElement.config.elementConfig.id}-tooltip`}
                                            tooltipContent={formElement.config.tooltipContent}
                                            tooltipConfig={formElement.config.tooltipConfig}>
                                            <Icon
                                                className="more-info-cards"
                                                isSmall="true">
                                            </Icon>
                                        </Tooltip>
                                        : null}
                                </div>
                                    <div className="textbox-tooltip-field">
                                        <FormElements
                                            valueType={formElement.id}
                                            elementType={formElement.config.elementType}
                                            elementConfig={formElement.config.elementConfig}
                                            value={formElement.config.isCountryField ? formElement.config.displayValue : formElement.config.value}
                                            classVal={inputClassName}
                                            changed={(event) => this.inputChangedHandler(event, formElement.config.fieldFormat, formElement.id, null, null, formElement.config.skipOnChangeValidation)}
                                            focusOut={(event) => this.focusOutValidationHandler(event, formElement.config.fieldFormat, formElement.id)}
                                            label={formElement.config.label}
                                            valid={formElement.config.isValid}
                                            touched={formElement.config.touched}
                                            onFocus={this.inputFocus}
                                            live={formElement.config.live}
                                            componentVersion={this.props.componentVersion}
                                            isComponentDisabled={this.props?.componentClassName?.includes("disabledContent")}
                                        />
                                    </div>
                                </> : <>
                                    <label htmlFor={formElement.config.elementConfig.name} className={formElement.config.value || formElement.config.touched ? "checkoutLabel active" : "checkoutLabel"}>{formElement.config.label}</label>
                                    <FormElements
                                        valueType={formElement.id}
                                        elementType={formElement.config.elementType}
                                        elementConfig={formElement.config.elementConfig}
                                        value={formElement.config.isCountryField ? formElement.config.displayValue : formElement.config.value}
                                        classVal={inputClassName}
                                        changed={(event) => this.inputChangedHandler(event, formElement.config.fieldFormat, formElement.id, null, null, formElement.config.skipOnChangeValidation)}
                                        focusOut={(event) => this.focusOutValidationHandler(event, formElement.config.fieldFormat, formElement.id)}
                                        label={formElement.config.label}
                                        valid={formElement.config.isValid}
                                        touched={formElement.config.touched}
                                        onFocus={this.inputFocus}
                                        live={formElement.config.live}
                                        componentVersion={this.props.componentVersion}
                                        isComponentDisabled={this.props?.componentClassName?.includes("disabledContent")}
                                    />
                                </>}
                            {formElement.config.cardBrand ?
                                <span className="input-card-type-image">
                                    <img
                                        className="card-type-logo"
                                        style={{ width: '45px' }}
                                        alt={formElement.config.cardBrand}
                                        src={checkoutDetailDataUtil.getCreditCardVendorLogoImage(formElement.config.cardBrand, this.props.scriptingJson.creditCardVendors)} />
                                </span> : null}
                            {formElement.config.showViewOption && formElement.config.value ?
                                //eslint-disable-next-line
                                <a
                                    className="view-link d-block caption-two"
                                    tabIndex="0"
                                    role="button"
                                    aria-label={`${this.props.scriptingJson[constantValues._LNK_VIEW]} ${this.props.scriptingJson[constantValues._LBL_FORM_PASSWORD_WITHOUT_ASTRIK]}`}
                                    name={`${formElement.config.elementConfig.id}Anchor`}
                                    onKeyPress={(event) => { if (event.key === "Enter") { this.passwordFieldDisplayHandler(formElement.config.elementConfig.id) } }}
                                    onClick={() => this.passwordFieldDisplayHandler(formElement.config.elementConfig.id)}>{this.props.scriptingJson[constantValues._LNK_VIEW]}</a> : null}
                        </div>
                        {!_.isEmpty(formElement.config.errorDescriptions) && this.addErrorForBtnAccessibility(formElement.config, ariaDescribedByArr)&&!(formElement?.config?.elementConfig?.id==="rafMinInput"|| formElement?.config?.elementConfig?.id==="rafCodeInput")?
                            <p id={formElement.id + this.state.formType + "error"} aria-live={formElement.config.showAriaLive ? "assertive" : "off"} className={formElement.config.errorClassName ? formElement.config.errorClassName : "error-text legal mt-10"}>{formElement.config.errorDescriptions[formElement.config.errorType]}</p> : null}
                        
                        {!_.isEmpty(formElement?.config?.errorDescriptions)&&this.addErrorForBtnAccessibility(formElement?.config,ariaDescribedByArr)&&(formElement?.config?.elementConfig?.id==="rafMinInput"|| formElement?.config?.elementConfig?.id==="rafCodeInput")&&formElement?.config?.errorType?
                            <>
                            {/TOTAL_WIRELESS/i.test(formElement?.config?.brandName)?
                                <p id={formElement.id + this.state.formType + "error"} aria-live={formElement.config.showAriaLive ? "assertive" : "off"} className={formElement.config.errorClassName ? formElement.config.errorClassName : "error-text legal mt-10"}>
                                    <span class="icon dark-theme large-icon">
                                        <i class="error-total-red"></i>
                                    </span>
                                    {formElement?.config?.errorDescriptions[formElement?.config?.errorType]}
                                </p>
                                :
                                <p id={formElement.id + this.state.formType + "error"} aria-live={formElement.config.showAriaLive ? "assertive" : "off"} className={formElement.config.errorClassName ? formElement.config.errorClassName : "error-text legal mt-10"}>{formElement.config.errorDescriptions[formElement.config.errorType]}</p>}
                        </>:null}
                    </div>
                );
            } else if ("multiple" === formElement.config.fieldFormat && "textbox" === formElement.config.fieldType) {
                const fieldClasses = formElement.config.fieldClasses;
                const isStraighttalkBrand = /STRAIGHT_TALK/i.test(this.props.scriptingJson[constantValues.API_BRAND_NAME]);
                FormDefinitionElem = (
                    <div className="row ml-0 mr-0" key={formElement.id}>
                        {Object.keys(formElement.config).map(formElementKey => {
                            return _.isObject(formElement.config[formElementKey]) ? [...Array(formElement.config[formElementKey])].map((formElementObj) => {
                                let inputClassName = formElementObj.isValid && formElementObj.touched ? formElementObj.elementConfig.className + " success" : '';
                                inputClassName = formElementObj.errorType && !formElementObj.isValid ? `${inputClassName} error` : inputClassName;
                                return (<div className={!fieldClasses ? formElementObj.isFirstField ? "col-6 pb-10 pl-0 pr-3" : "col-6 pb-10 pr-0 pl-3" : fieldClasses} key={formElementKey}>
                                    <div className="md-form input-group alternate mt-0 mb-0 bg-soft-grey">
                                        <label htmlFor={formElementObj.elementConfig.name} className={formElementObj.value ? "checkoutLabel active" : "checkoutLabel"}>{formElementObj.label}</label>
                                        {/\b(v1)\b/i.test(this.props.componentVersion) ?
                                        <FormElements
                                            ariaDescribedBy={`${formElementKey}${this.state.formType}error ${formElementObj.isCityField ? "ariaDescElement" + formElementObj.elementConfig.id : ""}`}
                                            ariaLabel="This Field is changed to* "
                                            valueType={formElementKey}
                                            elementType={formElementObj.elementType}
                                            elementConfig={formElementObj.elementConfig}
                                            value={formElementObj.value}
                                            classVal={(this.props.getMarketSegmentError || this.props.editShippingMarketSegmentError) && (formElementObj.elementConfig.id === "customerZip" || formElementObj.elementConfig.id === "editShippingCustomerZip") ? `${inputClassName} error` :  inputClassName}
                                            changed={(event) => this.inputChangedHandler(event, formElement.config.fieldFormat, formElement.id, formElementKey,null,null,formElementObj.isCheckoutShippingZip)}
                                            focusOut={(event) => !formElementObj?.isCheckoutShippingZip?this.focusOutValidationHandler(event, formElement.config.fieldFormat, formElement.id, formElementKey):null}
                                            label={formElementObj.label}
                                            valid={formElementObj.isValid}
                                            componentVersion={this.props.componentVersion}
                                            isComponentDisabled={this.props?.componentClassName?.includes("disabledContent")}
                                            touched={formElementObj.touched} /> :  
                                            <FormElements
                                            ariaDescribedBy={`${formElementKey}${this.state.formType}error ${!_.isEmpty(formElementObj.ariaRequiredDescription)||formElementObj.isCityField ? "ariaDescElement" + formElementObj.elementConfig.id : ""}`}
                                            valueType={formElementKey}
                                            elementType={formElementObj.elementType}
                                            elementConfig={formElementObj.elementConfig}
                                            value={formElementObj.value}
                                            classVal={(this.props.getMarketSegmentError || this.props.editShippingMarketSegmentError) && (formElementObj.elementConfig.id === "customerZip" || formElementObj.elementConfig.id === "editShippingCustomerZip") ? `${inputClassName} error` :  inputClassName}
                                            changed={(event) => this.inputChangedHandler(event, formElement.config.fieldFormat, formElement.id, formElementKey,null,null,formElementObj.isCheckoutShippingZip)}
                                            focusOut={(event) => !formElementObj?.isCheckoutShippingZip?this.focusOutValidationHandler(event, formElement.config.fieldFormat, formElement.id, formElementKey):null}
                                            label={formElementObj.isCardExpiryField && formElementObj.elementConfig["aria-label"] ? formElementObj.elementConfig["aria-label"] : formElementObj.label}
                                            valid={formElementObj.isValid}
                                            componentVersion={this.props.componentVersion}
                                            isComponentDisabled={this.props?.componentClassName?.includes("disabledContent")}
                                            touched={formElementObj.touched} />}
                                    </div>

                                    {isStraighttalkBrand && this.props.getMarketSegmentError && formElementObj.elementConfig.id === "customerZip" ? (
                                        <div className="mksg-error-message-container">
                                            <div className="mksg-error-icon-text-wrapper">
                                                <div className='mksg-error-icon-aligment'>
                                                    <svg xmlns="http://www.w3.org/2000/svg" width="18" height="19" viewBox="0 0 18 19" fill="none">
                                                        <path fillRule="evenodd" clipRule="evenodd" d="M1.19922 9.20332C1.19922 4.89297 4.68887 1.40332 8.99922 1.40332C13.3096 1.40332 16.7992 4.89297 16.7992 9.20332C16.7992 13.5137 13.3029 17.0033 8.99922 17.0033C4.69554 17.0033 1.19922 13.5137 1.19922 9.20332ZM12.8598 6.44526C13.1643 6.14071 13.1649 5.64707 12.8605 5.34247C12.5559 5.03789 12.0617 5.03794 11.757 5.34247L8.99905 8.10047L6.24106 5.34247C5.93654 5.03816 5.44354 5.03825 5.13897 5.34247C4.83442 5.64702 4.83385 6.14063 5.13828 6.44526L7.89627 9.20325L5.13828 11.9612C4.83384 12.2659 4.83442 12.7595 5.13897 13.064C5.44353 13.3684 5.93650 13.3684 6.24106 13.064L8.99905 10.306L11.757 13.064C12.0617 13.3686 12.5559 13.3686 12.8605 13.064C13.1648 12.7594 13.1643 12.2657 12.8598 11.9612L10.1018 9.20325L12.8598 6.44526Z" fill="black" />
                                                    </svg>
                                                </div>
                                                <p className="mksg-error-text">
                                                    {this.props.getMarketSegmentError}
                                                </p>
                                            </div>
                                        </div>
                                    ) : (
                                        <p className="error-text legal mt-10">{this.props.getMarketSegmentError && formElementObj.elementConfig.id === "customerZip" ? this.props.getMarketSegmentError : ""}</p>
                                    )}

                                    {isStraighttalkBrand && this.props.editShippingMarketSegmentError && formElementObj.elementConfig.id === "editShippingCustomerZip"  ? (
                                        <div className="mksg-error-message-container">
                                            <div className="mksg-error-icon-text-wrapper">
                                                <div className='mksg-error-icon-aligment'>
                                                    <svg xmlns="http://www.w3.org/2000/svg" width="18" height="19" viewBox="0 0 18 19" fill="none">
                                                        <path fillRule="evenodd" clipRule="evenodd" d="M1.19922 9.20332C1.19922 4.89297 4.68887 1.40332 8.99922 1.40332C13.3096 1.40332 16.7992 4.89297 16.7992 9.20332C16.7992 13.5137 13.3029 17.0033 8.99922 17.0033C4.69554 17.0033 1.19922 13.5137 1.19922 9.20332ZM12.8598 6.44526C13.1643 6.14071 13.1649 5.64707 12.8605 5.34247C12.5559 5.03789 12.0617 5.03794 11.757 5.34247L8.99905 8.10047L6.24106 5.34247C5.93654 5.03816 5.44354 5.03825 5.13897 5.34247C4.83442 5.64702 4.83385 6.14063 5.13828 6.44526L7.89627 9.20325L5.13828 11.9612C4.83384 12.2659 4.83442 12.7595 5.13897 13.064C5.44353 13.3684 5.93650 13.3684 6.24106 13.064L8.99905 10.306L11.757 13.064C12.0617 13.3686 12.5559 13.3686 12.8605 13.064C13.1648 12.7594 13.1643 12.2657 12.8598 11.9612L10.1018 9.20325L12.8598 6.44526Z" fill="black" />
                                                    </svg>
                                                </div>
                                                <p className="mksg-error-text">
                                                    {this.props.editShippingMarketSegmentError}
                                                </p>
                                            </div>
                                        </div>
                                    ) : (
                                        <p className="error-text legal mt-10">{this.props.editShippingMarketSegmentError && formElementObj.elementConfig.id === "editShippingCustomerZip" ? this.props.editShippingMarketSegmentError : ""}</p>
                                    )}

                                    
                                    
                                    
                                    {!_.isEmpty(formElementObj.fieldInfoLabel) ?
                                        <p className='emailFieldInfo'>{formElementObj.fieldInfoLabel}</p> : null}
                                    {!_.isEmpty(formElementObj.errorDescriptions) && this.addErrorForBtnAccessibility(formElementObj, ariaDescribedByArr) ?
                                        <p id={formElementKey + this.state.formType + "error"} className="error-text legal mt-10">{formElementObj.errorDescriptions[formElementObj.errorType]}</p> : null}
                                    {(!/\b(v1)\b/i.test(this.props.componentVersion) && !_.isEmpty(formElementObj.ariaRequiredDescription))||formElementObj.isCityField ?
                                        <p id={"ariaDescElement" + formElementObj.elementConfig.id} className="d-none"> {formElementObj.isCityField ? (this.props.mapQuestLoading ? this.props.scriptingJson[constantValues._LBL_LOADING_CITY] : <span></span>) : formElementObj.ariaRequiredDescription}</p> : null}
                                    {formElementObj.isCityField ?
                                        <p className="sr-only" aria-live="polite">{this.state.updatedZipCode ? `${this.props.scriptingJson[constantValues._LBL_CITY_UPDATED] ? this.props.scriptingJson[constantValues._LBL_CITY_UPDATED] : constantValues._LBL_CITY_UPDATED} ${this.state.updatedZipCode}` : " "}</p>
                                    : null}
                                </div>)
                            }) : null;
                        })}
                    </div>
                )
            } else if ("single" === formElement.config.fieldFormat && "dropdown" === formElement.config.fieldType && !formElement.config.accessible) {
                FormDefinitionElem = (
                    <div className="col-12 pb-10 pl-0 pr-0" key={formElement.id}>
                        {/* eslint-disable-next-line */}
                        <label tabIndex={/\b(v1)\b/i.test(this.props.componentVersion) && this.props?.componentClassName?.includes("disabledContent") ? constantValues.TAB_INDEX_MINUS_ONE : constantValues.TAB_INDEX_ZERO} onKeyUp={(event) => this.dropDownKeyUpHandler(event, formElement.id)} onKeyPress={(event) => { if (event.key === "Enter") { this.dropdownLabelVisibilityHandler(formElement.config.fieldFormat, formElement.id) } }} aria-describedby={formElement.id + this.state.formType + "SelectedSpan"} className="field-spa pl-0 pr-0 alternate dropdown-label bg-soft-grey" htmlFor={formElement.id + "Field"} style={formElement.config.labelMaxWidth ? { opacity: 1, maxWidth: formElement.config.labelMaxWidth } : { opacity: 1 }} id={formElement.id + this.state.formType + "Label"} aria-expanded="false" role="combobox"  aria-label={formElement.config.label}>
                            <span className="sr-only">{formElement.config.label}</span>
                            <span id={formElement.id + this.state.formType + "LabelSpan"} className={formElement.config.value ? "place-holder-selected" : void 0} aria-hidden="true">{formElement.config.label}</span>
                            <div id={formElement.id + this.state.formType + "Field"} className="psuedo_select-spa" name={formElement.id + "Field"} onClick={() => this.dropdownLabelVisibilityHandler(formElement.config.fieldFormat, formElement.id)}>
                                {formElement.config.showImage ?
                                    <span className="d-block" style={{ 'top': '-5px' }}>
                                        <img style={{ 'width': '18px' }} src={formElement.config.imageSource} alt={formElement.config.displayValue} />
                                    </span> : null}
                                <span
                                    className={formElement.config.isValid && formElement.config.validation.required ? "selected success" : formElement.config.showImage ? "selected line-list" : "selected"}
                                    id={formElement.id + this.state.formType + "SelectedSpan"}
                                    value={formElement.config.value}
                                    role="alert"
                                    ref={this.selectedSpanRef}>{formElement.config.displayValue}</span>
                                <ul id={formElement.id + this.state.formType} className="options" style={{ height: 'auto', scrollBehavior: 'smooth' }} aria-hidden={/\b(v1)\b/i.test(this.props.componentVersion) && this.props?.componentClassName?.includes("disabledContent") ? "false" : "true"} role="listbox">
                                    {_.isArray(formElement.config.options) ? formElement.config.options.map((optionObj, index) => {
                                        return <FormElements
                                            key={optionObj.value}
                                            dataIndex={index}
                                            ariaDescribedBy={`${formElement.id}${this.state.formType}error`}
                                            valueType={formElement.id}
                                            elementType={formElement.config.elementType}
                                            elementConfig={formElement.config.elementConfig}
                                            elementId={formElement.id + this.state.formType + "ListElement"}
                                            accessId={`${formElement.id}${this.state.formType}ListElement${index}`}
                                            value={optionObj.value}
                                            role="option"
                                            keyPress={() => this.inputChangedHandler(optionObj.value, formElement.config.fieldFormat, formElement.id, null, formElement.config.options)}
                                            click={() => this.inputChangedHandler(optionObj.value, formElement.config.fieldFormat, formElement.id, null, formElement.config.options)}>{optionObj.displayValue}</FormElements>
                                    }) : null}
                                </ul>
                            </div>
                        </label>
                        {!_.isEmpty(formElement.config.errorDescriptions) ?
                            <p id={formElement.id + this.state.formType + "error"} className="error-text legal mt-10">{formElement.config.errorDescriptions[formElement.config.errorType]}</p> : null}
                    </div>
                )
            } else if ("single" === formElement.config.fieldFormat && "checkbox" === formElement.config.fieldType && (_.isUndefined(formElement.config.isLoggedInUserField) || this.props.isLoggedIn === formElement.config.isLoggedInUserField)) {
                /* determine input group class name based on various parameter */
                let inputGroupClassName = `col-12 pb-10 pl-0 pr-0 ${this.props?.formDefinition?.termsAndConditions?.className ? this.props?.formDefinition?.termsAndConditions?.className : ``}`;
                let checkboxClassName = "";
                if (formElement.config.isDisabled) {
                    inputGroupClassName = "col-12 pb-10 pl-0 pr-0 disabled";
                } else if (formElement.config.isHidden) {
                    inputGroupClassName = "col-12 pb-10 pl-0 pr-0 d-none";
                } else if (this.state.formType == constantValues.FORM_TYPE_RAF_CODE) {
                    checkboxClassName = isNewImplementation ? 'ml-15' : "text-center";
                }
                //Code to add disabled attribute to anchor tag when component section is disabled starts here
                if(formElement.config.includeHTML !== undefined && this.props?.componentClassName?.includes("disabledContent")) {
                    let repeatedIndex = [];
                    for (let i = 0; i < formElement.config.includeHTML.length; i++) {
                        if (formElement.config.includeHTML.charAt(i) === '<' && formElement.config.includeHTML.charAt(i+1) === 'a') {
                            repeatedIndex.push(i);
                        }
                        if (formElement.config.includeHTML.charAt(i) === '<' && formElement.config.includeHTML.charAt(i+1) === '/' && formElement.config.includeHTML.charAt(i+2) === 'a' && formElement.config.includeHTML.charAt(i+3) === '>') {
                            repeatedIndex.push(i);
                        }
                    }
                    for (let i = 0; i < repeatedIndex.length; i += 2) {
                        let word = formElement.config.includeHTML.slice(repeatedIndex[i], repeatedIndex[i+1]);
                        if (!word.includes('disabled')) {
                            formElement.config.includeHTML = formElement.config.includeHTML.replaceAll('<a', '<a tabindex="-1" disabled');
                        }
                    }
                }
                //Code to add disabled attribute to anchor tag when component section is disabled ends here
               
                //Code to remove disabled attribute to anchor tag when component section is enabled starts here
                if(formElement.config.includeHTML !== undefined && !this.props?.componentClassName?.includes("disabledContent")) {
                    let repeatedIndex = [];
                    for (let i = 0; i < formElement.config.includeHTML.length; i++) {
                        if (formElement.config.includeHTML.charAt(i) === '<' && formElement.config.includeHTML.charAt(i+1) === 'a') {
                            repeatedIndex.push(i);
                        }
                        if (formElement.config.includeHTML.charAt(i) === '<' && formElement.config.includeHTML.charAt(i+1) === '/' && formElement.config.includeHTML.charAt(i+2) === 'a' && formElement.config.includeHTML.charAt(i+3) === '>') {
                            repeatedIndex.push(i);
                        }
                    }
                    for (let i = 0; i < repeatedIndex.length; i += 2) {
                        let word = formElement.config.includeHTML.slice(repeatedIndex[i], repeatedIndex[i+1]);
                        if (word.includes('disabled')) {
                            formElement.config.includeHTML = formElement.config.includeHTML.replaceAll('<a tabindex="-1" disabled', '<a');
                        }
                    }
                }
                //Code to remove disabled attribute to anchor tag when component section is enabled ends here
                let ariaDescribedBy = undefined;
                if(formElement?.config?.elementConfig?.id === "giftCheckBox" && /\b(v2)\b/i.test(this.props.componentVersion)){
                    ariaDescribedBy = formElement.config.label;
                }

                FormDefinitionElem = (
                    <div className={inputGroupClassName} key={formElement.id}>
                        <div className={`custom-control custom-checkbox-spa mt-auto pl-0 pr-0 checkbox-inside-choiceCard ${formElement.config.tooltipContent ? "checkbox-tooltip" : ""} ${checkboxClassName}`}>
                            <FormElements
                                valueType={formElement.id}
                                elementType={formElement.config.fieldType}
                                elementConfig={formElement.config.elementConfig}
                                valid={formElement.config.isValid}
                                ariaLabel={ariaDescribedBy}
                                value={formElement.id}
                                componentVersion={this.props.componentVersion}
                                isComponentDisabled={this.props?.componentClassName?.includes("disabledContent")}
                                changed={(event) => { this.inputChangedHandler(event, formElement.config.fieldFormat, formElement.id) }}
                                isChecked={formElement.config.touched} />
                            <label
                                className="custom-control-label"
                                htmlFor={formElement.config.elementConfig.id}>
                                <div className={formElement.config.labelDivClass ? formElement.config.labelDivClass : "mt-10 mb-10"}>
                                    <p className="caption-one text-color-grey">{formElement.config.label}</p>
                                </div>
                                {formElement.config.includeHTML ? <div className={formElement.config.labelDivClass ? formElement.config.labelDivClass : "mt-10 mb-10"} dangerouslySetInnerHTML={{ __html: formElement.config.includeHTML }}></div> : null}
                            </label>
                            {formElement.config.tooltipContent ?
                                <Tooltip
                                    tooltipContent={formElement.config.tooltipContent}
                                    ariaLabel={formElement.config.tooltipAriaLabel}
                                    tooltipConfig={formElement.config.tooltipConfig}
                                />
                                : null}
                        </div>
                    </div>
                )
            } else if ("single" === formElement.config.fieldFormat && "toggle" === formElement.config.fieldType && !formElement.config.isHidden && (_.isUndefined(formElement.config.isLoggedInUserField) || this.props.isLoggedIn === formElement.config.isLoggedInUserField) && !formElement.config.refillCard) {
                FormDefinitionElem = (
                    <div className="default-switch" key={formElement.id}>
                        <div className="row">
                            <div className="col-7">
                                <p className="caption-one-normal pt-2">{formElement.config.label}</p>
                            </div>
                            <div className="col-5 text-right">
                                <div className="custom-control custom-switch p-0">
                                    <FormElements
                                        valueType={formElement.id}
                                        elementType={formElement.config.elementType}
                                        elementConfig={formElement.config.elementConfig}
                                        label={formElement.config.label}
                                        valid={formElement.config.isValid}
                                        value={formElement.id}
                                        changed={() => { }}
                                        isChecked={formElement.config.touched} />
                                    <label
                                        className="custom-control-label"
                                        htmlFor={formElement.config.elementConfig.id}
                                        onClick={(event) => this.inputChangedHandler(event, formElement.config.fieldFormat, formElement.id)}></label>
                                </div>
                            </div>
                        </div>
                    </div>
                )
            } else if ("single" === formElement.config.fieldFormat && "gifttextarea" === formElement.config.fieldType) {
                const maxChar = formElement.config.characterLimitGiftMessage || null;
                FormDefinitionElem = (
                    <div key={formElement.id} style={{ width: '100%' }} className={this.props.isGiftMessageEnabled ? "gift-info-container" : "gift-info-container d-none"} tabindex="-1">
                        <p className="caption-three-bold text-color-grey text-uppercase">{formElement.config.heading}</p>
                        <div className="col-12 pt-10 pb-10 pl-0 pr-0">
                            <div className="md-form alternate text-area">
                                <label htmlFor={formElement.config.elementConfig.id}>{formElement.config.label}</label>
                                <FormElements
                                    elementType={formElement.config.elementType}
                                    elementConfig={formElement.config.elementConfig}
                                    label={`${formElement.config.heading} ${formElement.config.label}`}
                                    value={formElement.config.value}
                                    onPaste={(event) => { if (event.key === "Enter" || !constantValues.NO_SPECIAL_CHARS.test(event.clipboardData.getData('text'))) { event.preventDefault(); } }}
                                    keyPress={(event) => { if (event.key === "Enter" || !constantValues.NO_SPECIAL_CHARS.test(event.key)) { event.preventDefault(); } }}
                                    changed={(event) => this.inputChangedHandler(event, formElement.config.fieldFormat, formElement.id)} />
                            </div>
                            <p id={formElement.config.elementConfig['aria-describedby']} className="text-color-grey caption-two text-right">{formElement.config.characterCountLabel}
                                <span id="characterCount">{formElement.config.value.length}</span>
                                <span>{formElement.config.characterLimitGiftMessage ? `/${formElement.config.characterLimitGiftMessage}` : null}</span>
                                {parseInt(formElement.config.value.length,10) === parseInt(maxChar,10)?<span className='visually-hidden'>Reached maximum character limit</span>:''}
                            </p>
                        </div>
                    </div>
                )
            } else if ("single" === formElement.config.fieldFormat && "text" === formElement.config.fieldType && !formElement.config.isHidden && this.props.isLoggedIn === formElement.config.isLoggedInUserField) {
                FormDefinitionElem = (
                    /\b(v1)\b/i.test(this.props.componentVersion) ?
                        <p className="legal text-color-grey pb-10" tabIndex="0" aria-label={formElement.config.value} key={formElement.id}>
                            <Icon className="error-black" extraClass="pr-1" />
                            {formElement.config.value}
                        </p> :
                        <p className="legal text-color-grey pb-10" key={formElement.id}>
                            <Icon className="error-black" extraClass="pr-1" />
                            {formElement.config.value}
                        </p>
                )
            } else if ("single" === formElement.config.fieldFormat && "reCaptcha" === formElement.config.fieldType && !formElement.config.isHidden) {
                FormDefinitionElem = (
                    <div className={formElement.config.isHidden ? "d-none" : "mb-15 captcha-wrapper text-center"} id="recaptcha-spa-impl" key={formElement.id}>
                        <ReCAPTCHA
                            sitekey={process.env.NODE_ENV === 'development' ? "6LeIxAcTAAAAAJcZVRqyHh71UMIEGNQ_MXjiZKhI" : this.props.scriptingJson[constantValues.RECAPTCHA_SITE_KEY]}
                            ref={this.props.captchaRef}
                            onChange={(recaptchaToken) => this.props.onInitDetailUpdateInMyAccountStore(recaptchaToken, "recaptchaToken")} />
                    </div>
                )
            } else if ("single" === formElement.config.fieldFormat && "dropdown" === formElement.config.fieldType) {
                FormDefinitionElem = (
                    <FormDropDown
                        key={formElement.id}
                        formElement={formElement}
                        inputChangedHandler={this.inputChangedHandler}
                        formType={this.state.formType} />
                )
            } else if ("single" === formElement.config.fieldFormat && "label" === formElement.config.fieldType && !formElement.config.isHidden) {
                FormDefinitionElem = (
                    <p className={formElement.config.notificationClass} key={formElement.id}>
                        {formElement.config.value}
                    </p>
                )
            }
                else if("single"===formElement.config.fieldFormat&&"toggle"===formElement.config.fieldType&&!formElement.config.isHidden&&
                (_.isUndefined(formElement.config.isLoggedInUserField)||this.props.isLoggedIn===formElement.config.isLoggedInUserField)&&(this?.props?.state?.formDefinition?.formType !== "ModifySavedCreditCard") && (this.props?.accountProfileData?.accountLevelAutoRefillStatus === true || !_.isEmpty(this.props?.accountProfileData?.autoRefill)) && sessionStorage.editPayment !== "true" &&(!window.location.pathname.includes("manage-auto-refill"))){
                    if(this.props.accountProfileData?.activeLines>1){
                        FormDefinitionElem=(
                            <div key={formElement.id}>
                                <p className="caption-one-info text-color-grey pb-10"><Icon className="error-black" extraClass="pr-1" />
                                    {this.props.scriptingJson[constantValues._LBL_AUTO_REFILL_ENROLLMENT_PAYMENT_INFO]}
                                </p>
                            </div>
                        )
                    }else{
                    FormDefinitionElem = (
                        <div className ="default-switch" key={formElement.id}>
                            <div className="row">
                            <div className="col-7">
                                <p className="caption-one-normal pt-2">{formElement.config.label}</p>
                            </div>
                            <div className="col-5 text-right">
                                <div className="custom-control custom-switch p-0">
                                    <FormElements
                                        valueType={formElement.id}
                                        elementType={formElement.config.elementType}
                                        elementConfig={formElement.config.elementConfig}
                                        label={formElement.config.label}
                                        valid={formElement.config.isValid}
                                        value={formElement.id}
                                        changed={() => {}}
                                        isChecked={formElement.config.touched}/>
                                    <label
                                        className="custom-control-label"
                                        htmlFor={formElement.config.elementConfig.id}
                                        onClick={(event) => this.inputChangedHandler(event,formElement.config.fieldFormat,formElement.id)}></label>
                                </div>
                            </div>
                            </div>
                        </div>
                    )
                    }
                }
                //isMultiline
            return FormDefinitionElem;
        });

        return (
            <form autoComplete="off" {...this.props?.state?.alertRoleRequired && {'role' : 'alert'}}  className={`forms-row ${this.props.formClassName ?? ''} ${formClass}`}>
                {formStructure}
                {this.props.addFormErrorsBtnAccessibility ? 
                    <p className="d-none" id={`${this.state.formType}BtnErrors`}>{!_.isEmpty(ariaDescribedByArr) ? ariaDescribedByArr.join(" ") : ""}</p>
                : null}
            </form>
        )
    }
}

Forms.propTypes = {
    state: PropTypes.object,
    isLoggedIn: PropTypes.bool,
    scriptingJson: PropTypes.object,
    creditCardVendors: PropTypes.array,
    componentVersion: PropTypes.string,
    mapQuestStateName: PropTypes.string,
    mapQuestCityName: PropTypes.string,
    mapQuestCountryName: PropTypes.string,
    mapQuestFormType: PropTypes.string,
    componentClassName: PropTypes.string,
    mapQuestErrorMessage: PropTypes.string,
    dropDownFormFieldData: PropTypes.object,
    updateCreditCardVendorIconHandler: PropTypes.func,
    onInitFormDetailUpdateInStore: PropTypes.func,
};

const mapStateToProps = state => {
    return {
        isLoggedIn: state.authDetail.isLoggedIn,
        creditCardVendors: state.checkoutDetail.creditCardVendors,
        dropDownFormFieldData: state.checkoutDetail.dropDownFormFieldData,
        mapQuestStateName: state.checkoutDetail.mapQuestData.stateName,
        mapQuestCityName: state.checkoutDetail.mapQuestData.cityName,
        mapQuestCountryName: state.checkoutDetail.mapQuestData.countryName,
        mapQuestFormType: state.checkoutDetail.mapQuestData.formType,
        dropDownFormFieldAccess: state.checkoutDetail.dropDownFormFieldAccess,
        mapQuestErrorMessage: state.checkoutDetail.mapQuestData.mapQuestApiErrorMessage,
        mapQuestLoading: state.checkoutDetail.mapQuestLoading,
        accountProfileData: state.myAccount.accountProfileData,
        getMarketSegmentError : state.cartDetail.getMarketSegmentError,
        editShippingMarketSegmentError: state.cartDetail.editShippingMarketSegmentError
    }
}

const mapDispatchToProps = dispatch => {
    return {
        onInitFormDetailUpdateInStore: (formDetailsJson, formName) => dispatch(actions.initFormDetailUpdateInStore(formDetailsJson, formName)),
        onInitUpdateCityStateInStore: (mapQuestApiUrl, formType) => dispatch(actions.initUpdateCityState(mapQuestApiUrl, formType)),
        onInitDetailUpdateInMyAccountStore: (detailsJson, itemName, isCommunicationPreference) => dispatch(actions.initDetailUpdateInMyAccountStore(detailsJson, itemName, isCommunicationPreference)),
        resetMarketSegmentError : () => dispatch(actions.resetMarketSegmentError()),
        editShippingMarketSegmentErrorHandler: (msg) => dispatch(actions.editShippingMarketSegmentErrorHandler(msg))
    }
}

export default connect(mapStateToProps, mapDispatchToProps)(Forms);
